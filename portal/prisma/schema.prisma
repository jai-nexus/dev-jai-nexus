generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Repo {
  id            Int       @id @default(autoincrement())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt

  nhId          String    @default("")
  name          String    @unique
  description   String?
  domainPod     String?
  engineGroup   String?
  language      String?
  status        String?
  owner         String?
  defaultBranch String?
  githubUrl     String?
  notes         Json?

  syncRuns      SyncRun[]
  domains       Domain[]
  sotEvents     SotEvent[]

  fileIndexes   FileIndex[]
}

model Domain {
  id         Int       @id @default(autoincrement())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now()) @updatedAt

  nhId       String    @default("")
  domain     String    @unique
  status     String?
  domainKey  String?
  engineType String?
  env        String?
  expiresAt  DateTime?
  notes      Json?

  repoId     Int?
  repo       Repo?      @relation(fields: [repoId], references: [id])

  sotEvents  SotEvent[] // ðŸ‘ˆ new back-relation
}

model SyncRun {
  id             Int       @id @default(autoincrement())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt

  type           String
  status         String
  trigger        String?

  startedAt      DateTime
  finishedAt     DateTime

  workflowRunUrl String?
  summary        String?
  payload        Json?

  repoId         Int?
  repo           Repo?     @relation(fields: [repoId], references: [id])

  fileIndexes    FileIndex[]
}
model FileIndex {
  id            Int       @id @default(autoincrement())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt

  // FK: which repo this file belongs to
  repoId        Int
  repo          Repo      @relation(fields: [repoId], references: [id])

  // Optional link back to SyncRun that produced this snapshot
  syncRunId     Int?
  syncRun       SyncRun?  @relation(fields: [syncRunId], references: [id])

  // Path info
  path          String    // "portal/src/app/operator/projects/page.tsx"
  dir           String    // "portal/src/app/operator/projects"
  filename      String    // "page.tsx"
  extension     String    // "tsx"

  // File characteristics
  sizeBytes     Int
  sha256        String
  lastCommitSha String?

  // When this row was indexed (redundant with createdAt but explicit)
  indexedAt     DateTime  @default(now())

  @@index([repoId])
  @@index([extension])
  @@unique([repoId, path])
}

model PilotSession {
  id         Int       @id @default(autoincrement())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now()) @updatedAt

  // For now, just free-form hooks; we can replace with real FK to Project/Wave later.
  projectKey String?   // e.g. "Dev<INFRA>Ops"
  waveLabel  String?   // e.g. "Wave 7"

  mode       String    // "observer" | "guide" | "autopilot"
  surface    String    // "web" | "vr" | "terminal" | ...

  createdBy  String    // "admin@jai.nexus" | "agent@jai.nexus" | etc.

  startedAt  DateTime  @default(now())
  endedAt    DateTime?

  actions    PilotAction[]

  @@index([surface])
}

model PilotAction {
  id             Int       @id @default(autoincrement())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt

  // When the action actually occurred (can differ from createdAt if backfilled)
  ts             DateTime  @default(now())

  sessionId      Int
  session        PilotSession @relation(fields: [sessionId], references: [id])

  mode           String    // snapshot of session mode at time of action
  targetNodeId   String?   // Scene Graph node (DOM node ID, VR panel ID, etc.)
  actionType     String    // "click" | "type" | "scroll" | "open_tab" | "focus_panel" | ...
  payload        String?   // JSON/text payload (typed text, URL, etc.)
  reason         String    // natural-language rationale (can be empty for pure observer)

  @@index([sessionId])
  @@index([mode])
  @@index([actionType])
}

model JaiTool {
  id           Int       @id @default(autoincrement())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now()) @updatedAt

  name         String
  version      String?
  description  String?
  scope        String?
  status       String?

  inputSchema  Json?
  outputSchema Json?
}

model SotEvent {
  id         Int       @id @default(autoincrement())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now()) @updatedAt

  /// When the event actually happened (not when we ingested it)
  ts         DateTime

  /// High-level source: chatgpt | github | notion | manual | jai-format | etc.
  source     String

  /// Logical type: conversation | decision | task | design_note | sync | etc.
  kind       String

  /// Optional NH marker for this event in your hierarchy (e.g. "2.1.3.5")
  nhId       String    @default("")

  /// Short human-readable summary for dashboards
  summary    String?

  /// Full canonical blob (usually jai-format or raw export)
  payload    Json?

  /// Optional links into repo/domain registries
  repoId     Int?
  repo       Repo?     @relation(fields: [repoId], references: [id])

  domainId   Int?
  domain     Domain?   @relation(fields: [domainId], references: [id])

  @@index([ts, repoId, domainId])
}

// --- Auth / RBAC ---

enum Role {
  ADMIN
  AGENT
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt

  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?

  passwordHash String?

  role          Role      @default(AGENT)

  // Auth.js relations
  accounts      Account[]
  sessions      Session[]
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?  @db.Text
  access_token      String?  @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?  @db.Text
  session_state     String?

  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
