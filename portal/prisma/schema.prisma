// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  // Q1 hardening: "driverAdapters" preview feature is deprecated.
  // Leave this off unless you have a known adapter flow requiring it.
  // previewFeatures = ["driverAdapters"]

  // If you want a custom output folder, uncomment:
  // output = "generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ─────────────────────────────────────────────────────────────────────────────
// ENUMS (Q1 hardening: eliminate status/env drift)
// ─────────────────────────────────────────────────────────────────────────────

enum RepoStatus {
  active
  frozen
  planned
  parked
}

enum DomainStatus {
  live
  planned
  parked
}

enum DomainEnv {
  prod
  stage
  dev
}

enum Role {
  ADMIN
  AGENT
}

enum WorkPacketStatus {
  DRAFT
  PLANNED
  IN_PROGRESS
  IN_REVIEW
  BLOCKED
  DONE
}

enum InboxItemStatus {
  QUEUED
  CLAIMED
  IN_PROGRESS
  PROPOSED
  DONE
  BLOCKED
  CANCELED
}

// Q1 deterministic workflow primitives
enum WaveRunState {
  READY
  PLANNING
  EXECUTING
  VERIFYING
  RELEASING
  ARCHIVING
  COMPLETE
  FAILED
  CANCELED
}

enum GateRunStatus {
  PENDING
  RUNNING
  PASS
  FAIL
  SKIP
}

enum AgentRunStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
  CANCELED
}

// ─────────────────────────────────────────────────────────────────────────────
// CORE MODELS
// ─────────────────────────────────────────────────────────────────────────────

model Repo {
  id            Int         @id @default(autoincrement())
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @default(now()) @updatedAt
  nhId          String      @default("")
  name          String      @unique
  description   String?
  domainPod     String?
  engineGroup   String?
  language      String?
  status        RepoStatus?
  owner         String?
  defaultBranch String?
  githubUrl     String?
  notes         Json?

  wave         Int? // 0..3 or null (unassigned)
  isDeprecated Boolean @default(false)

  domains     Domain[]
  fileIndexes FileIndex[]
  sotEvents   SotEvent[]
  syncRuns    SyncRun[]

  // inverse relation for WorkPacket.repo
  workPackets WorkPacket[]

  @@index([nhId])
  @@index([wave])
  @@index([isDeprecated])
}

model Domain {
  id         Int           @id @default(autoincrement())
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @default(now()) @updatedAt
  nhId       String        @default("")
  domain     String        @unique
  status     DomainStatus?
  domainKey  String?
  engineType String?
  env        DomainEnv?
  expiresAt  DateTime?
  notes      Json?

  repoId Int?
  repo   Repo? @relation(fields: [repoId], references: [id], onDelete: SetNull)

  sotEvents SotEvent[]

  @@index([nhId])
}

model SyncRun {
  id             Int      @id @default(autoincrement())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @default(now()) @updatedAt
  type           String
  status         String
  trigger        String?
  startedAt      DateTime
  finishedAt     DateTime
  workflowRunUrl String?
  summary        String?
  payload        Json?

  repoId Int?
  repo   Repo? @relation(fields: [repoId], references: [id], onDelete: SetNull)

  fileIndexes FileIndex[]
}

model FileIndex {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt
  repoId        Int
  syncRunId     Int?
  path          String
  dir           String
  filename      String
  extension     String
  sizeBytes     Int
  sha256        String
  lastCommitSha String?
  indexedAt     DateTime @default(now())

  repo    Repo     @relation(fields: [repoId], references: [id], onDelete: Cascade)
  syncRun SyncRun? @relation(fields: [syncRunId], references: [id], onDelete: SetNull)

  @@unique([repoId, path])
  @@index([repoId])
  @@index([extension])
}

model PilotSession {
  id         Int           @id @default(autoincrement())
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @default(now()) @updatedAt
  projectKey String?
  waveLabel  String?
  mode       String
  surface    String
  createdBy  String
  startedAt  DateTime      @default(now())
  endedAt    DateTime?
  actions    PilotAction[]

  @@index([surface])
}

model PilotAction {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  ts           DateTime @default(now())
  sessionId    Int
  mode         String
  targetNodeId String?
  actionType   String
  payload      String?
  reason       String

  session PilotSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([mode])
  @@index([actionType])
}

model PilotRun {
  id          Int       @id @default(autoincrement())
  kind        String
  status      String
  startedAt   DateTime  @default(now())
  finishedAt  DateTime?
  summary     String?
  artifactDir String?
  stdoutPath  String?
  stderrPath  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model JaiTool {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  name         String
  version      String?
  description  String?
  scope        String?
  status       String?
  inputSchema  Json?
  outputSchema Json?
}

model SotEvent {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  ts     DateTime
  source String
  kind   String

  nhId    String  @default("")
  eventId String  @unique
  summary String?
  payload Json?

  repoId   Int?
  domainId Int?

  domain Domain? @relation(fields: [domainId], references: [id], onDelete: SetNull)
  repo   Repo?   @relation(fields: [repoId], references: [id], onDelete: SetNull)

  workPacketId Int?
  workPacket   WorkPacket? @relation(fields: [workPacketId], references: [id], onDelete: SetNull)

  chatId Int?
  chat   Chat? @relation(fields: [chatId], references: [id], onDelete: SetNull)

  @@index([ts])
  @@index([kind])
  @@index([source])
  @@index([nhId])
  @@index([workPacketId, ts])
  @@index([ts, repoId, domainId])
}

// ─────────────────────────────────────────────────────────────────────────────
// AUTH (Auth.js style)
// ─────────────────────────────────────────────────────────────────────────────

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  role          Role      @default(AGENT)
  passwordHash  String?

  accounts Account[]
  sessions Session[]

  inboxItems AgentInboxItem[]

  // Q1 deterministic agent runs (optional link)
  agentRuns AgentRun[]
  waveRuns  WaveRun[]  @relation("WaveRunCreatedBy")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ─────────────────────────────────────────────────────────────────────────────
// WORK PACKETS + INBOX
// ─────────────────────────────────────────────────────────────────────────────

model WorkPacket {
  id Int @id @default(autoincrement())

  externalId String? @unique

  nhId   String
  title  String
  status WorkPacketStatus @default(DRAFT)

  ac   String @default("")
  plan String @default("")

  githubIssueUrl  String?
  githubPrUrl     String?
  verificationUrl String?

  repoId Int?
  repo   Repo? @relation(fields: [repoId], references: [id], onDelete: SetNull)

  // Q1: attach packets to a WaveRun for deterministic wave execution
  waveRunId Int?
  waveRun   WaveRun? @relation(fields: [waveRunId], references: [id], onDelete: SetNull)

  sotEvents  SotEvent[]
  inboxItems AgentInboxItem[]

  // ✅ Agent delegation queue (1:1 optional backref)
  agentQueueItem AgentQueueItem? @relation("AgentQueueItemToWorkPacket")

  // optional linkage to agent runs/artifacts
  agentRuns AgentRun[]
  artifacts Artifact[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([nhId])
  @@index([status])
  @@index([waveRunId])
}

model AgentInboxItem {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  status   InboxItemStatus @default(QUEUED)
  priority Int             @default(50)

  lockedAt    DateTime?
  lockedByRun String?
  claimedAt   DateTime?
  completedAt DateTime?

  agentUserId String?
  agent       User?   @relation(fields: [agentUserId], references: [id], onDelete: SetNull)

  workPacketId Int        @unique
  workPacket   WorkPacket @relation(fields: [workPacketId], references: [id], onDelete: Cascade)

  tags  String[] @default([])
  notes Json?

  @@index([status, priority])
  @@index([agentUserId, status])
}

// ─────────────────────────────────────────────────────────────────────────────
// Q1 REGISTRY SNAPSHOT CACHE (SoT file → DB cache)
// ─────────────────────────────────────────────────────────────────────────────

model RegistrySnapshot {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  quarter     String // e.g. "2026-Q1"
  version     String // e.g. "v0.1"
  locked      Boolean   @default(false)
  lockedAt    DateTime?
  contentHash String // sha256 of canonical normalized repos.yaml payload
  sourcePath  String // e.g. "portal/config/repos.yaml"
  notes       Json?

  repos    RegistryRepo[]
  waveRuns WaveRun[]

  @@unique([quarter, version])
  @@index([quarter])
  @@index([locked])
}

model RegistryRepo {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  snapshotId Int
  snapshot   RegistrySnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)

  nhId         String
  repo         String
  description  String?
  tier         Int?
  role         String?
  status       RepoStatus?
  wave         Int?
  isDeprecated Boolean     @default(false)
  notes        Json?

  @@unique([snapshotId, nhId])
  @@index([nhId])
  @@index([wave])
  @@index([status])
}

// ─────────────────────────────────────────────────────────────────────────────
// Q1 WAVE EXECUTION + GATES + AGENT RUNS + ARTIFACTS
// ─────────────────────────────────────────────────────────────────────────────

model WaveRun {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  quarter String // e.g. "2026-Q1" (denormalized for quick filtering)
  wave    Int // 0..3
  state   WaveRunState @default(READY)

  startedAt  DateTime?
  finishedAt DateTime?
  summary    String?
  notes      Json?

  snapshotId Int
  snapshot   RegistrySnapshot @relation(fields: [snapshotId], references: [id], onDelete: Restrict)

  createdByUserId String?
  createdBy       User?   @relation("WaveRunCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  workPackets WorkPacket[]
  gateRuns    GateRun[]
  agentRuns   AgentRun[]
  artifacts   Artifact[]

  @@index([quarter, wave])
  @@index([state])
  @@index([snapshotId])
}

model GateRun {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  waveRunId Int
  waveRun   WaveRun @relation(fields: [waveRunId], references: [id], onDelete: Cascade)

  gateId String // e.g. "registry_hash_matches"
  status GateRunStatus @default(PENDING)

  startedAt  DateTime?
  finishedAt DateTime?
  summary    String?
  results    Json?

  @@unique([waveRunId, gateId])
  @@index([gateId])
  @@index([status])
}

model AgentRun {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  agentId String // e.g. "jai_architect"
  action  String // e.g. "plan_wave", "import_registry", "run_gates"
  status  AgentRunStatus @default(QUEUED)

  startedAt  DateTime?
  finishedAt DateTime?
  summary    String?
  inputs     Json?
  outputs    Json?
  errors     Json?

  // optional links
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  waveRunId Int?
  waveRun   WaveRun? @relation(fields: [waveRunId], references: [id], onDelete: SetNull)

  workPacketId Int?
  workPacket   WorkPacket? @relation(fields: [workPacketId], references: [id], onDelete: SetNull)

  artifacts Artifact[]

  @@index([agentId])
  @@index([action])
  @@index([status])
  @@index([waveRunId])
  @@index([workPacketId])
}

model Artifact {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  type    String // "run_plan" | "action_log" | "evidence_pack" | "result" | "registry_snapshot" etc
  label   String?
  uri     String?
  sha256  String?
  content Json?
  meta    Json?

  waveRunId Int?
  waveRun   WaveRun? @relation(fields: [waveRunId], references: [id], onDelete: SetNull)

  agentRunId Int?
  agentRun   AgentRun? @relation(fields: [agentRunId], references: [id], onDelete: SetNull)

  workPacketId Int?
  workPacket   WorkPacket? @relation(fields: [workPacketId], references: [id], onDelete: SetNull)

  @@index([type])
  @@index([sha256])
  @@index([waveRunId])
  @@index([agentRunId])
  @@index([workPacketId])
}

// ─────────────────────────────────────────────────────────────────────────────
// SOURCES RELEVANCE LOOP (Phase 3)
// ─────────────────────────────────────────────────────────────────────────────

model SourceSignal {
  id              String   @id @default(cuid())
  version         String
  ts              DateTime
  date            String // YYYY-MM-DD
  quarter         String // YYYY-Qn
  vendor          String
  title           String
  url             String
  published_at    String?
  tier            String?
  artifact_path   String
  artifact_sha256 String   @unique
  summary         String?
  createdAt       DateTime @default(now())

  @@index([vendor, date])
  @@index([ts])
}

// ─────────────────────────────────────────────────────────────────────────────
// CHAT MEMORY SYSTEM (Q1 2026 - Personal Knowledge Continuity)
// ─────────────────────────────────────────────────────────────────────────────

model Chat {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  chatId   String   @unique
  title    String
  source   String
  chatDate DateTime

  filepath    String?
  contentHash String?
  fullText    String  @db.Text

  model String?
  nhId  String   @default("")
  tags  String[] @default([])
  notes Json?

  decisions Decision[]
  sotEvents SotEvent[]

  @@index([chatDate])
  @@index([source])
  @@index([nhId])
  @@index([chatId])
}

model Decision {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  text    String  @db.Text
  context String? @db.Text

  chatId Int
  chat   Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  lineNumber   Int?
  decisionDate DateTime?
  category     String?
  status       String    @default("active")

  nhId           String @default("")
  supersededById Int?

  @@index([chatId])
  @@index([status])
  @@index([category])
  @@index([decisionDate])
}

enum AgentQueueStatus {
  PENDING
  CLAIMED
  IN_PROGRESS
  COMPLETED
  FAILED
}

model AgentQueueItem {
  id           String   @id @default(uuid())
  workPacketId Int      @unique
  agentNhId    String
  repoScope    String[] @default([])

  status      AgentQueueStatus @default(PENDING)
  claimedAt   DateTime?
  leaseExpiry DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  workPacket WorkPacket @relation("AgentQueueItemToWorkPacket", fields: [workPacketId], references: [id])
}
