generator client {
  provider = "prisma-client-js"
  output   = "generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ENUMS (Q1 hardening: eliminate status/env drift)
enum RepoStatus {
  active
  frozen
  planned
  parked
}

enum DomainStatus {
  live
  planned
  parked
}

enum DomainEnv {
  prod
  stage
  dev
}

model Repo {
  id            Int         @id @default(autoincrement())
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @default(now()) @updatedAt
  nhId          String      @default("")
  name          String      @unique
  description   String?
  domainPod     String?
  engineGroup   String?
  language      String?
  status        RepoStatus?
  owner         String?
  defaultBranch String?
  githubUrl     String?
  notes         Json?

  domains     Domain[]
  fileIndexes FileIndex[]
  sotEvents   SotEvent[]
  syncRuns    SyncRun[]

  // inverse relation for WorkPacket.repo
  workPackets WorkPacket[]

  @@index([nhId])
}

model Domain {
  id         Int           @id @default(autoincrement())
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @default(now()) @updatedAt
  nhId       String        @default("")
  domain     String        @unique
  status     DomainStatus?
  domainKey  String?
  engineType String?
  env        DomainEnv?
  expiresAt  DateTime?
  notes      Json?

  repoId Int?
  repo   Repo? @relation(fields: [repoId], references: [id], onDelete: SetNull)

  sotEvents SotEvent[]

  @@index([nhId])
}

model SyncRun {
  id             Int      @id @default(autoincrement())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @default(now()) @updatedAt
  type           String
  status         String
  trigger        String?
  startedAt      DateTime
  finishedAt     DateTime
  workflowRunUrl String?
  summary        String?
  payload        Json?

  repoId Int?
  repo   Repo? @relation(fields: [repoId], references: [id], onDelete: SetNull)

  fileIndexes FileIndex[]
}

model FileIndex {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt
  repoId        Int
  syncRunId     Int?
  path          String
  dir           String
  filename      String
  extension     String
  sizeBytes     Int
  sha256        String
  lastCommitSha String?
  indexedAt     DateTime @default(now())

  repo    Repo     @relation(fields: [repoId], references: [id], onDelete: Cascade)
  syncRun SyncRun? @relation(fields: [syncRunId], references: [id], onDelete: SetNull)

  @@unique([repoId, path])
  @@index([repoId])
  @@index([extension])
}

model PilotSession {
  id         Int           @id @default(autoincrement())
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @default(now()) @updatedAt
  projectKey String?
  waveLabel  String?
  mode       String
  surface    String
  createdBy  String
  startedAt  DateTime      @default(now())
  endedAt    DateTime?
  actions    PilotAction[]

  @@index([surface])
}

model PilotAction {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  ts           DateTime @default(now())
  sessionId    Int
  mode         String
  targetNodeId String?
  actionType   String
  payload      String?
  reason       String

  session PilotSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([mode])
  @@index([actionType])
}

model PilotRun {
  id          Int       @id @default(autoincrement())
  kind        String
  status      String
  startedAt   DateTime  @default(now())
  finishedAt  DateTime?
  summary     String?
  artifactDir String?
  stdoutPath  String?
  stderrPath  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model JaiTool {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  name         String
  version      String?
  description  String?
  scope        String?
  status       String?
  inputSchema  Json?
  outputSchema Json?
}

model SotEvent {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  /// When the event actually happened (not when we ingested it)
  ts     DateTime
  /// High-level source: chatgpt | github | notion | manual | dev-portal | etc.
  source String
  /// Logical type: conversation | decision | task | sync | WORK_PACKET_CREATED | etc.
  kind   String

  /// Optional NH marker for this event in your hierarchy (e.g. "2.1.3.5")
  nhId    String  @default("")
  summary String?
  payload Json?

  repoId   Int?
  domainId Int?

  domain Domain? @relation(fields: [domainId], references: [id], onDelete: SetNull)
  repo   Repo?   @relation(fields: [repoId], references: [id], onDelete: SetNull)

  /// Stable anchor for WorkPacket streams (nhId can change)
  workPacketId Int?
  workPacket   WorkPacket? @relation(fields: [workPacketId], references: [id], onDelete: SetNull)

  @@index([ts])
  @@index([kind])
  @@index([source])
  @@index([nhId])
  @@index([workPacketId, ts])
  @@index([ts, repoId, domainId])
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  role          Role      @default(AGENT)
  passwordHash  String?

  accounts Account[]
  sessions Session[]

  // ✅ Agent inbox items assigned to this user (optional assignment)
  inboxItems AgentInboxItem[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum Role {
  ADMIN
  AGENT
}

enum WorkPacketStatus {
  DRAFT
  PLANNED
  IN_PROGRESS
  IN_REVIEW
  BLOCKED
  DONE
}

model WorkPacket {
  id     Int              @id @default(autoincrement())
  nhId   String
  title  String
  status WorkPacketStatus @default(DRAFT)

  ac   String @default("")
  plan String @default("")

  githubIssueUrl  String?
  githubPrUrl     String?
  verificationUrl String?

  repoId Int?
  repo   Repo? @relation(fields: [repoId], references: [id], onDelete: SetNull)

  /// Inverse relation for SotEvent.workPacket
  sotEvents SotEvent[]

  // ✅ Agent inbox queue entries for this work packet
  inboxItems AgentInboxItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([nhId])
  @@index([status])
}

// ✅ Q1: Agent Inbox
enum InboxItemStatus {
  QUEUED
  CLAIMED
  IN_PROGRESS
  PROPOSED
  DONE
  BLOCKED
  CANCELED
}

model AgentInboxItem {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  status      InboxItemStatus @default(QUEUED)
  priority    Int             @default(50)
  lockedAt    DateTime?
  lockedByRun String? // runner instance id (optional)
  claimedAt   DateTime?
  completedAt DateTime?

  // who it’s assigned to (optional; can start as unassigned backlog)
  agentUserId String?
  agent       User?   @relation(fields: [agentUserId], references: [id], onDelete: SetNull)

  workPacketId Int
  workPacket   WorkPacket @relation(fields: [workPacketId], references: [id], onDelete: Cascade)

  // small metadata for routing (keep it simple)
  tags  String[] @default([])
  notes Json?

  @@unique([workPacketId, agentUserId])
  @@index([status, priority])
  @@index([agentUserId, status])
}
