generator client {
  provider = "prisma-client-js"
  output   = "generated/prisma"
}

datasource db {
  provider = "postgresql"
  // NOTE: no `url` here – Prisma 7 reads it from prisma.config.ts
}

model Repo {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt
  nhId          String   @default("")
  name          String   @unique
  description   String?
  domainPod     String?
  engineGroup   String?
  language      String?
  status        String?
  owner         String?
  defaultBranch String?
  githubUrl     String?
  notes         Json?

  domains     Domain[]
  fileIndexes FileIndex[]
  sotEvents   SotEvent[]
  syncRuns    SyncRun[]

  // ✅ inverse relation for WorkPacket.repo
  workPackets WorkPacket[]
}

model Domain {
  id         Int        @id @default(autoincrement())
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @default(now()) @updatedAt
  nhId       String     @default("")
  domain     String     @unique
  status     String?
  domainKey  String?
  engineType String?
  env        String?
  expiresAt  DateTime?
  notes      Json?
  repoId     Int?
  repo       Repo?      @relation(fields: [repoId], references: [id])
  sotEvents  SotEvent[]
}

model SyncRun {
  id             Int         @id @default(autoincrement())
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @default(now()) @updatedAt
  type           String
  status         String
  trigger        String?
  startedAt      DateTime
  finishedAt     DateTime
  workflowRunUrl String?
  summary        String?
  payload        Json?
  repoId         Int?
  fileIndexes    FileIndex[]
  repo           Repo?       @relation(fields: [repoId], references: [id])
}

model FileIndex {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt
  repoId        Int
  syncRunId     Int?
  path          String
  dir           String
  filename      String
  extension     String
  sizeBytes     Int
  sha256        String
  lastCommitSha String?
  indexedAt     DateTime @default(now())
  repo          Repo     @relation(fields: [repoId], references: [id])
  syncRun       SyncRun? @relation(fields: [syncRunId], references: [id])

  @@unique([repoId, path])
  @@index([repoId])
  @@index([extension])
}

model PilotSession {
  id         Int           @id @default(autoincrement())
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @default(now()) @updatedAt
  projectKey String?
  waveLabel  String?
  mode       String
  surface    String
  createdBy  String
  startedAt  DateTime      @default(now())
  endedAt    DateTime?
  actions    PilotAction[]

  @@index([surface])
}

model PilotAction {
  id           Int          @id @default(autoincrement())
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @default(now()) @updatedAt
  ts           DateTime     @default(now())
  sessionId    Int
  mode         String
  targetNodeId String?
  actionType   String
  payload      String?
  reason       String
  session      PilotSession @relation(fields: [sessionId], references: [id])

  @@index([sessionId])
  @@index([mode])
  @@index([actionType])
}

model PilotRun {
  id          Int       @id @default(autoincrement())
  kind        String // e.g. "sync-repos"
  status      String // "running" | "success" | "failed"
  startedAt   DateTime  @default(now())
  finishedAt  DateTime?
  summary     String?
  artifactDir String?
  stdoutPath  String?
  stderrPath  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model JaiTool {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  name         String
  version      String?
  description  String?
  scope        String?
  status       String?
  inputSchema  Json?
  outputSchema Json?
}

model SotEvent {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  /// When the event actually happened (not when we ingested it)
  ts        DateTime
  /// High-level source: chatgpt | github | notion | manual | jai-format | etc.
  source    String
  /// Logical type: conversation | decision | task | design_note | sync | etc.
  kind      String
  /// Optional NH marker for this event in your hierarchy (e.g. "2.1.3.5")
  nhId      String   @default("")
  /// Short human-readable summary for dashboards
  summary   String?
  /// Full canonical blob (usually jai-format or raw export)
  payload   Json?
  /// Optional links into repo/domain registries
  repoId    Int?
  domainId  Int?
  domain    Domain?  @relation(fields: [domainId], references: [id])
  repo      Repo?    @relation(fields: [repoId], references: [id])

  @@index([ts, repoId, domainId])
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  role          Role      @default(AGENT)
  passwordHash  String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum Role {
  ADMIN
  AGENT
}

enum WorkPacketStatus {
  DRAFT
  PLANNED
  IN_PROGRESS
  IN_REVIEW
  BLOCKED
  DONE
}

model WorkPacket {
  id     Int              @id @default(autoincrement())
  nhId   String
  title  String
  status WorkPacketStatus @default(DRAFT)

  ac   String @default("")
  plan String @default("")

  githubIssueUrl  String?
  githubPrUrl     String?
  verificationUrl String?

  repoId Int?
  repo   Repo? @relation(fields: [repoId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt // ✅ ADD default(now())

  @@index([nhId])
  @@index([status])
}
